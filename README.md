# üöÄ Challenge_Start

## ‚öôÔ∏è Instalaci√≥n y Ejecuci√≥n
1. üñ•Ô∏è Abre una terminal de comandos en tu sistema.
2. üì¶ Clona el repositorio con https o SSH:
    ```bash
    #https
    git clone https://github.com/Sebastian-G-0607/Challenge_Start.git
    #SSH
    git clone git@github.com:Sebastian-G-0607/Challenge_Start.git
    ```
3. üîç Verifica que tienes node.js y pnpm instalados:
    ```bash
    node -v
    pnpm -v
    ```
    Deber√≠as ver las versiones instaladas en tu sistema. 
    Si no tienes `node.js`, puedes instalarlo desde [Node.js](https://nodejs.org/).

    Si no tienes `pnpm`, puedes instalarlo globalmente con:
    ```bash
    npm install -g pnpm
     ```

4. üìÇ Navega al directorio del proyecto:
    ```bash
    cd Challenge_Start/solution
    ```
5. üì• Instala las dependencias:
    ```bash
    pnpm install
    ```
6. ‚ñ∂Ô∏è Ejecuta la aplicaci√≥n en modo desarrollo:
    ```bash
    pnpm run dev
    ```
#### üéâ ¬°Listo! Ahora la aplicaci√≥n deber√≠a estar corriendo en `http://localhost:4000`.

---

## üõ†Ô∏è Configuraciones y solicitudes
Esta aplicaci√≥n permite configurar mocks para diferentes rutas y m√©todos HTTP. Puedes enviar solicitudes para configurar, obtener o eliminar mocks.

Para configurar un mock, debes usar la siguiente estructura en tu solicitud POST:
### üìù Estructura de la solicitud
```json
{
     "path": "/ruta/del/mock",
     "method": "GET|POST|PUT|DELETE",
     "queryParams": {
          "param1": "valor1",
          "param2": "valor2"
     },
     "bodyParams": {
          "param1": "valor1",
          "param2": "valor2"
     },
     "headers": {
          "header1": "valor1",
          "header2": "valor2"
     },
     "status": 200,
     //La respuesta puede ser un objeto JSON
     "response": {
          "message": "Respuesta personalizada",
          "data": "Data de la respuesta"
     },
     // O bien un HTML
     "response": "<html><body><h1>Respuesta HTML</h1></body></html>",

     "contentType": "application/json|text/html"
}
```

---

### üß© Configurar un Mock
Por ejemplo, para configurar un mock que responda a una solicitud POST a `/api/servicios/home` con ciertos par√°metros, puedes ejecutar el siguiente comando en la terminal:

```bash
curl -X POST http://localhost:4000/configure-mock \
     -H "Content-Type: application/json" \
     -d '{                                   
        "path": "/api/servicios/home",
        "method": "POST",
        "queryParams": {
            "categoria": "residenciales",
            "nivel": 1,
            "admin": false
        },
        "bodyParams": {
            "ubicacion": "gt"
        },
        "headers": {
            "authorization": "Bearer 123"
        },
        "status": 201,
        "response": { 
            "message": "Bienvenido {{usuario}}, est√°s viendo el panel de servicios residenciales",
            "usuario": true
        },
        "contentType": "application/json"
    }'
```

‚ú® `{{usuario}}` se reemplazar√° por el valor del par√°metro `usuario` enviado en la url de la solicitud. Esto permite personalizar la respuesta seg√∫n los par√°metros de la solicitud.

---

### üîç Obtener un Mock previamente configurado
Para obtener la respuesta del mock configurado aqu√≠ arriba, puedes hacer una solicitud GET a la ruta configurada. Es importante que se env√≠en todos los datos necesarios tanto en la ruta como en el body de la request. De igual forma, los headers como el Authorization deben incluirse y coincidir. Por ejemplo:

```bash
curl -X POST "http://localhost:4000/api/servicios/home?categoria=residenciales&nivel=1&usuario=TigoClient&admin=false" \
     -H "authorization: Bearer 123" \
     -H "Content-Type: application/json" \
     -d '{
          "ubicacion": "gt"
     }'
```

---

### üëë Mock con usuario administrador
Si quieres un mock que responda a un usuario administrador, puedes configurar el mock de la siguiente manera, con un parametro admin en la url:

```bash
curl -X POST http://localhost:4000/configure-mock \
     -H "Content-Type: application/json" \
     -d '{
          "path": "/api/servicios/home",
          "method": "POST",
          "queryParams": {
                "categoria": "residenciales",
                "nivel": 1,
                "admin": true
          },
          "bodyParams": {
                "ubicacion": "gt"
          },
          "headers": {
                "authorization": "Bearer 123"
          },
          "status": 201,
          "response": {
                "message": "Bienvenido {{usuario}}, est√°s viendo el panel de administrador de {{empresa}}",
                "usuario": true
          },
          "contentType": "application/json"
     }'
```
Luego, puedes hacer una solicitud GET a la ruta configurada con el par√°metro `admin`:

```bash
curl -X POST "http://localhost:4000/api/servicios/home?categoria=residenciales&nivel=1&usuario=TigoAdmin&admin=true&empresa=Tigo" \
     -H "authorization: Bearer 123" \
     -H "Content-Type: application/json" \
     -d '{
          "ubicacion": "gt"
     }'
```

---

### üìã Obtener todos los Mocks configurados
Para obtener todos los mocks configurados, puedes hacer una solicitud GET a `/configure-mock`
```bash
curl -X GET http://localhost:4000/configure-mock
```

---

### üóëÔ∏è Eliminar un Mock configurado
Para eliminar un mock previamente configurado, puedes hacer una solicitud DELETE a `/configure-mock/:{id}`, donde `{id}` es el ID del mock que deseas eliminar. Por ejemplo:

```bash
curl -X DELETE http://localhost:4000/configure-mock/12345
```
Primero se recomienda obtener la lista de mocks configurados para identificar el ID del mock que deseas eliminar. Puedes hacerlo con la solicitud GET a `/configure-mock`.

---

### üñºÔ∏è Mock que retorna un HTML
Si deseas que un mock retorne un HTML, puedes configurar el mock de la siguiente manera:
```bash
curl -X POST http://localhost:4000/configure-mock \
     -H "Content-Type: application/json" \
     -d '{
          "path": "/api/home/about-us",
          "method": "GET",
          "queryParams": {
                "categoria": "Challenge_Start"
          },
          "headers": {
                "authorization": "Bearer 1234"
          },
          "status": 200,
          "response": "<html><body><h1>Bienvenido {{usuario}}</h1><p>En esta p√°gina encontrar√°s informaci√≥n sobre nuestra empresa. Ubicaci√≥n: {{ubicacion}}</p></body></html>",
          "contentType": "text/html"
     }'
```
Luego, puedes hacer una solicitud GET a la ruta configurada:
```bash
curl -X GET "http://localhost:4000/api/home/about-us?categoria=Challenge_Start&usuario=TigoUser&ubicacion=Km%209.5%20Ctra%20a%20El%20Salvador,%20Santa%20Catarina%20Pinula,%20Torre%201" \
     -H "authorization: Bearer 1234" \
     -H "Content-Type: application/json"
```
### üîÑ Actualizar un Mock
Para actualizar un mock previamente configurado, puedes hacer una solicitud PUT a `/configure-mock/:{id}`, donde `{id}` es el ID del mock que deseas actualizar. Por ejemplo:
```bash
curl -X PUT http://localhost:4000/configure-mock/12345 \
     -H "Content-Type: application/json" \
     -d '{
          "path": "/api/servicios/admin"
     }'
```

Busca primero el ID del mock que deseas actualizar haciendo una solicitud GET a `/configure-mock`. Por ejemplo, el id del √∫ltimo mock en este caso es 1752265701691 (los ID son variables).

![Mocks guardados](./img/lista-mocks.png)


### Mock con m√©todo PUT
Si deseas configurar un mock que responda a un m√©todo PUT, puedes hacerlo de la siguiente manera:
```bash
curl -X POST http://localhost:4000/configure-mock \
     -H "Content-Type: application/json" \
     -d '{
          "path": "/api/home/planes",
          "method": "PUT",
          "queryParams": {
                "tv": "HD"
          },
          "bodyParams": {
                "usuario": "TigoUser"
          },
          "headers": {
                "authorization": "Bearer 123456"
          },
          "status": 201,
          "response": "<html><body><h1>Bienvenido {{usuario}}</h1><p>En esta p√°gina encontrar√°s informaci√≥n sobre nuestros planes de TV {{tv}}</p></body></html>",
          "contentType": "text/html"
     }'
```
Luego, puedes hacer una solicitud PUT a la ruta configurada:

```bash
curl -X PUT "http://localhost:4000/api/home/planes?tv=HD" \
     -H "Content-Type: application/json" \
     -H "authorization: Bearer 123456" \
     -d '{
          "usuario": "TigoUser"
     }'
```
Como ves, los par√°metos como "tv" o "usuario" pueden ser enviados en la query, en el body e incluso en los headers de la solicitud, y ser√°n reemplazados en la respuesta del mock. 

### Mock con m√©todo DELETE
Si deseas configurar un mock que responda a un m√©todo DELETE, puedes hacerlo de la siguiente manera:
```bash
curl -X POST http://localhost:4000/configure-mock \
     -H "Content-Type: application/json" \
     -d '{
          "path": "/api/home/planes",
          "method": "DELETE",
          "queryParams": {
                "usuario": "TigoUser"
          },
          "headers": {
                "authorization": "Bearer 123456"
          },
          "status": 204,
          "response": "<html><body><h1>Mock eliminado</h1></body></html>",
          "contentType": "text/html"
     }'
```
Luego, puedes hacer una solicitud DELETE a la ruta configurada:

```bash
curl -X DELETE "http://localhost:4000/api/home/planes?usuario=TigoUser" \
     -H "Content-Type: application/json" \
     -H "authorization: Bearer 123456"
```
Puede que no veas una respuesta en la terminal, pero la respuesta incluye el c√≥digo 204 que indica que la solicitud se ha procesado correctamente pero no hay contenido para devolver.

### Herramientas como Postman o Thunder Client
Puedes utilizar herramientas como Postman o Thunder Client para realizar pruebas de tus mocks de manera m√°s visual e interactiva. Estas herramientas te permiten configurar f√°cilmente las solicitudes HTTP, agregar encabezados, par√°metros y ver las respuestas de forma clara. Por ejemplo, con el mock configurado anteriormente con el m√©todo DELETE, puedes hacer una solicitud DELETE a la ruta `/api/home/planes` con los par√°metros necesarios y ver la respuesta en la interfaz de la herramienta.

![Eliminar un Mock configurado](./img/delete-mock.png)

De igual forma, puedes utilizar estas herramientas para ver todos los detalles de la respuesta, incluyendo el c√≥digo de estado, los encabezados y el cuerpo de la respuesta. Esto facilita la depuraci√≥n y prueba de los mocks.

![Endpoint desconocido](./img/unknown-endpoint.png)

### ‚úÖ Validaciones y Errores
Puedes modificar los mocks mostrados anteriormente o bien crear los tuyos completamente nuevos. La aplicaci√≥n valida que los par√°metros del mock est√©n correctamente estructurados y que los tipos de datos sean los esperados. Aqu√≠ hay algunas consideraciones importantes:

- La aplicaci√≥n valida que los par√°metros requeridos est√©n presentes y sean del tipo correcto.
- Si falta alg√∫n par√°metro obligatorio o hay un error en la estructura de la solicitud, se retorna un mensaje de error descriptivo.
- Los errores comunes incluyen:
    - ‚ùå Par√°metros faltantes o incorrectos al definir un mock.
    - ‚ùå Par√°metros mal definidos o no v√°lidos al actualizar un mock.
    - ‚ùå Intento de acceder a un mock que no existe.
    - ‚ùå Intento de acceder o eliminar un mock inexistente.
    - ‚ùå Mal formateo del JSON en la solicitud.
    - ‚ùå Errores generales del servidor.
- Todos los errores se devuelven en formato JSON con un mensaje claro para facilitar la depuraci√≥n.

###   üß™ Pruebas Unitarias
La aplicaci√≥n incluye pruebas unitarias para verificar el correcto funcionamiento de las rutas y la l√≥gica de negocio. Puedes ejecutar las pruebas con el siguiente comando:
```bash
pnpm run test
```
Esto ejecutar√° las pruebas definidas en la carpeta `tests` y mostrar√° los resultados en la terminal. 

---

## üèóÔ∏è Descripci√≥n de la arquitectura y dise√±o de la aplicaci√≥n
La aplicaci√≥n est√° dise√±ada para simular un servidor que responde a solicitudes HTTP con datos predefinidos (mocks). Utiliza Express.js para manejar las rutas y solicitudes, y permite configurar, obtener y eliminar mocks a trav√©s de una API RESTful. 

La arquitectura empleada es una arquitectura modular organizada dentro del enfoque monol√≠tico tradicional. Cuenta con un solo entrypoint que inicia el servidor backend, t√≠pico de esta arquitectura. La aplicaci√≥n est√° dividida en capas/funcionalidades que incluyen:


```
solution/
‚îú‚îÄ‚îÄ app/           # üè¢ Instancia de la aplicaci√≥n Express y definici√≥n de middlewares globales
‚îú‚îÄ‚îÄ controllers/   # üßë‚Äçüíª Controladores (funciones) de las rutas de la aplicaci√≥n
‚îú‚îÄ‚îÄ db/            # üíæ Configuraci√≥n y gesti√≥n de datos (simulaci√≥n de base de datos)
‚îú‚îÄ‚îÄ logs/          # üìë Funciones para ver informaci√≥n de logs y errores
‚îú‚îÄ‚îÄ middlewares/   # üõ°Ô∏è Middlewares personalizados
‚îú‚îÄ‚îÄ routes/        # üö¶ Definici√≥n de rutas y endpoints de la API
‚îú‚îÄ‚îÄ schemas/       # üìè Esquemas de validaci√≥n de datos con Zod
‚îú‚îÄ‚îÄ utils/         # üõ†Ô∏è Funciones utilitarias y helpers
‚îî‚îÄ‚îÄ tests/         # üß™ Pruebas unitarias
```
Durante el desarrollo de la aplicaci√≥n, utilic√© herramientas de IA para generar c√≥digo y mejorar la eficiencia del proceso. Aqu√≠ hay un resumen de los prompts utilizados:

### üí¨ Chat GPT
- **Explicaci√≥n general del challenge**: Ped√≠ a Chat GPT que me diera una descripci√≥n general del desaf√≠o y sus requisitos con el siguiente prompt:
  ```
  Expl√≠came el challenge que me est√°n pidiendo en este enunciado. No tengo experiencia previa con mocks y conozco muy poco de testing.
  ```
  Con la respuesta, obtuve una comprensi√≥n clara de los objetivos del challenge y c√≥mo deb√≠a abordar la implementaci√≥n. Adem√°s, en esta primera respuesta me proporcion√≥ el "esqueleto" de la aplicaci√≥n, lo que me ayud√≥ a estructurar el proyecto desde el principio.

- **Explicaci√≥n de herramientas de testing**: Tambi√©n consult√© si era estrictamente necesario utilizar herramientas de testing para este challenge. Para esto utilic√© el siguiente prompt:
  ```
  ¬øEl challenge requiere el uso de herramientas de testing?
  ```
  En un principio pens√© que era necesario ya que hab√≠a relacionado el t√©rmino "mock" con pruebas unitarias, pero la respuesta me aclar√≥ que no era obligatorio, por lo que al volver a leer el enunciado entend√≠ el reto de una mejor manera.

- **Explicaci√≥n de curl**: Para entender c√≥mo utilizar `curl` para enviar solicitudes HTTP, utilic√© el siguiente prompt:
  ```
  Expl√≠came qu√© es curl y c√≥mo usarlo para enviar solicitudes HTTP.
  ```
  Con esta informaci√≥n, pude realizar las solicitudes necesarias para configurar y probar los mocks.

- **Generaci√≥n de respuestas din√°micas**: Para implementar la funcionalidad de respuestas din√°micas basadas en par√°metros de la solicitud, utilic√© el siguiente prompt:
  ```
    Actualmente mis mocks pueden retornar respuestas est√°ticas, ¬øc√≥mo puedo implementar respuestas din√°micas basadas en plantillas?
    ```
    Con la respuesta entend√≠ que pod√≠a utilizar los par√°metros tanto del body como de la query para generar respuestas din√°micas, lo que me permiti√≥ personalizar las respuestas seg√∫n los datos enviados en la solicitud.

### üê≥ Deepseek
- **Comparaci√≥n de objetos en JS**: Para comparar objetos en JavaScript y verificar si son iguales, utilic√© el siguiente prompt:
  ```
  ¬øC√≥mo puedo comparar dos objetos en JavaScript para ver si son iguales?
    ```
    Con esta informaci√≥n pude validar que los parametros enviados en la solicitud coincidieran con los de los mocks guardados, lo que me permiti√≥ responder correctamente a las solicitudes.

- **Subir pnpm-lock.yaml a GitHub**: Para saber si es correcto subir el archivo `pnpm-lock.yaml` a GitHub, utilic√© el siguiente prompt:
  ```
  ¬øEs correcto subir el archivo pnpm-lock.yaml a GitHub?
  ```
  Con la respuesta entend√≠ que era una buena pr√°ctica incluir este archivo en el repositorio para asegurar que las dependencias se instalen de manera consistente en diferentes entornos.

### ü§ñ GitHub Copilot
- **Generaci√≥n de c√≥digo**: Utilic√© GitHub Copilot para ayudarme a generar c√≥digo de manera m√°s eficiente con ayuda de su autocompletado y sugerencias contextuales.

- **Tests unitarios**: Aunque no era obligatorio, decid√≠ implementar pruebas unitarias para asegurarme de que la aplicaci√≥n funcionara correctamente. Utilic√© GitHub Copilot para generar las pruebas basadas en los mocks configurados y las rutas definidas.